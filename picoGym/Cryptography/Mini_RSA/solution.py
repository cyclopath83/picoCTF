#!/usr/bin/env python

from decimal import *

# Seems to be a 2nd MiniRSA challenge in picoCTF. Using the same script, just different values for N and c.

# N = Decimal(1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287)
# e = Decimal(3)
# c = Decimal(1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147130204332030239454609548193370732857240300019596815816006860639254992255194738107991811397196500685989396810773222940007523267032630601449381770324467476670441511297695830038371195786166055669921467988355155696963689199852044947912413082022187178952733134865103084455914904057821890898745653261258346107276390058792338949223415878232277034434046142510780902482500716765933896331360282637705554071922268580430157241598567522324772752885039646885713317810775113741411461898837845999905524246804112266440620557624165618470709586812253893125417659761396612984740891016230905299327084673080946823376058367658665796414168107502482827882764000030048859751949099453053128663379477059252309685864790106)
N = Decimal(29331922499794985782735976045591164936683059380558950386560160105740343201513369939006307531165922708949619162698623675349030430859547825708994708321803705309459438099340427770580064400911431856656901982789948285309956111848686906152664473350940486507451771223435835260168971210087470894448460745593956840586530527915802541450092946574694809584880896601317519794442862977471129319781313161842056501715040555964011899589002863730868679527184420789010551475067862907739054966183120621407246398518098981106431219207697870293412176440482900183550467375190239898455201170831410460483829448603477361305838743852756938687673)
e = Decimal(3)
c = Decimal(2205316413931134031074603746928247799030155221252519872649649212867614751848436763801274360463406171277838056821437115883619169702963504606017565783537203207707757768473109845162808575425972525116337319108047893250549462147185741761825125)



def int_to_ascii(m):
    # Decode to ascii (from https://crypto.stackexchange.com/a/80346)
    m_hex = hex(int(m))[2:]  # Number to hex
    m_ascii = "".join(
        chr(int(m_hex[i : i + 2], 16)) for i in range(0, len(m_hex), 2)
    )  # Hex to Ascii
    return m_ascii


def main():
    # print the knowns
    print(f"N = {N}")
    print(f"e = {e}")
    print(f"c = {c}\n")
    print()

    # since they say that M**e is just bareley larger than N.
    # and c = M**e % N, we can assume that M**e = x*N + c, with x being a "small" number
    # since N is a large number, we need to increase the precision for our maths. (Not too high, or it will take way too long to calculate)
    getcontext().prec = 300
    for x in range(0, 10_000):
        # And e=3, thus we need to get the 3-rd square root of M**e to get M.
        # M**3**1/3 = M
        # M = (x*N + c)**1/3
        M = pow(x * N + c, 1 / e)

        # Convert the binary number to an ascii string
        m_ascii = int_to_ascii(M)
        if "pico" in m_ascii:
            print(f"x={x}")
            print(int_to_ascii(M))
            print()
            break

    # this did give us a partial flag, at x=3533. But it seems the precision wasn't high enough to get the full flag.
    # So lets increase the precision all the way up, and try the math once more (only once, with the known x)
    getcontext().prec = 9001
    M = pow(x * N + c, 1 / e)
    m_ascii = int_to_ascii(M)
    print(m_ascii)

    # Seems they forgot to add the ending }, but you can manually add that. (Or I did something wrong ;-) )

if __name__ == '__main__':
    main()
